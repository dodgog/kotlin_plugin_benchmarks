// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `Example$Companion`
class Example$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$Companion> $type;

  @jni$_.internal
  Example$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'Example$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$Companion$NullableType();
  static const type = $Example$Companion$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return Example$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $Example$Companion$NullableType
    extends jni$_.JObjType<Example$Companion?> {
  @jni$_.internal
  const $Example$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LExample$Companion;';

  @jni$_.internal
  @core$_.override
  Example$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Example$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Companion$NullableType) &&
        other is $Example$Companion$NullableType;
  }
}

final class $Example$Companion$Type extends jni$_.JObjType<Example$Companion> {
  @jni$_.internal
  const $Example$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LExample$Companion;';

  @jni$_.internal
  @core$_.override
  Example$Companion fromReference(jni$_.JReference reference) =>
      Example$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Companion?> get nullableType =>
      const $Example$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Companion$Type) &&
        other is $Example$Companion$Type;
  }
}

/// from: `Example`
class Example extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example> $type;

  @jni$_.internal
  Example.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'Example');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$NullableType();
  static const type = $Example$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LExample$Companion;',
  );

  /// from: `static public final Example$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Companion get Companion =>
      _id_Companion.get(_class, const $Example$Companion$Type());

  static final _id_ERROR_MESSAGE = _class.staticFieldId(
    r'ERROR_MESSAGE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ERROR_MESSAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString get ERROR_MESSAGE =>
      _id_ERROR_MESSAGE.get(_class, const jni$_.JStringType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_thinkBeforeAnswering = _class.instanceMethodId(
    r'thinkBeforeAnswering',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _thinkBeforeAnswering = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.lang.Object thinkBeforeAnswering(kotlin.coroutines.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> thinkBeforeAnswering() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _thinkBeforeAnswering(
            reference.pointer,
            _id_thinkBeforeAnswering as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress(await $p.first)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as(const jni$_.JStringType(), releaseOriginal: true);
  }

  static final _id_aloha = _class.instanceMethodId(
    r'aloha',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _aloha = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.util.List aloha(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JInteger> aloha(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _aloha(reference.pointer, _id_aloha as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JList<jni$_.JInteger>>(
            const jni$_.JListType<jni$_.JInteger>(jni$_.JIntegerType()));
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/String;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $Example$NullableType extends jni$_.JObjType<Example?> {
  @jni$_.internal
  const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LExample;';

  @jni$_.internal
  @core$_.override
  Example? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Example.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$NullableType) &&
        other is $Example$NullableType;
  }
}

final class $Example$Type extends jni$_.JObjType<Example> {
  @jni$_.internal
  const $Example$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LExample;';

  @jni$_.internal
  @core$_.override
  Example fromReference(jni$_.JReference reference) => Example.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Type) && other is $Example$Type;
  }
}

/// from: `Document`
class Document extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Document> $type;

  @jni$_.internal
  Document.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'Document');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Document$NullableType();
  static const type = $Document$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Document(
    jni$_.JObject context,
    jni$_.JString string,
  ) {
    final _$context = context.reference;
    final _$string = string.reference;
    return Document.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$context.pointer, _$string.pointer)
        .reference);
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()Ljava/util/Map;',
  );

  static final _getMetadata = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JObject> getMetadata() {
    return _getMetadata(
            reference.pointer, _id_getMetadata as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JObject>(
                jni$_.JStringType(), jni$_.JObjectType()));
  }

  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'()Ljava/lang/String;',
  );

  static final _getContent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getContent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getContent() {
    return _getContent(reference.pointer, _id_getContent as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $Document$NullableType extends jni$_.JObjType<Document?> {
  @jni$_.internal
  const $Document$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LDocument;';

  @jni$_.internal
  @core$_.override
  Document? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Document.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Document?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$NullableType) &&
        other is $Document$NullableType;
  }
}

final class $Document$Type extends jni$_.JObjType<Document> {
  @jni$_.internal
  const $Document$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LDocument;';

  @jni$_.internal
  @core$_.override
  Document fromReference(jni$_.JReference reference) => Document.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Document?> get nullableType => const $Document$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$Type) && other is $Document$Type;
  }
}

/// from: `com.example.database.DatabaseJniHelper`
class DatabaseJniHelper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DatabaseJniHelper> $type;

  @jni$_.internal
  DatabaseJniHelper.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/example/database/DatabaseJniHelper');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DatabaseJniHelper$NullableType();
  static const type = $DatabaseJniHelper$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatabaseJniHelper(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return DatabaseJniHelper.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$context.pointer)
        .reference);
  }

  static final _id_getEventsQueries = _class.instanceMethodId(
    r'getEventsQueries',
    r'()Lcom/exampledatabase/EventsQueries;',
  );

  static final _getEventsQueries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final com.exampledatabase.EventsQueries getEventsQueries()`
  /// The returned object must be released after use, by calling the [release] method.
  EventsQueries getEventsQueries() {
    return _getEventsQueries(
            reference.pointer, _id_getEventsQueries as jni$_.JMethodIDPtr)
        .object<EventsQueries>(const $EventsQueries$Type());
  }

  static final _id_execQuery = _class.instanceMethodId(
    r'execQuery',
    r'(Lapp/cash/sqldelight/Query;)Ljava/util/List;',
  );

  static final _execQuery = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final java.util.List execQuery(app.cash.sqldelight.Query query)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<Events> execQuery(
    Query<Events> query,
  ) {
    final _$query = query.reference;
    return _execQuery(reference.pointer, _id_execQuery as jni$_.JMethodIDPtr,
            _$query.pointer)
        .object<jni$_.JList<Events>>(
            const jni$_.JListType<Events>($Events$Type()));
  }

  static final _id_benchmarkEventInserts = _class.instanceMethodId(
    r'benchmarkEventInserts',
    r'()Ljava/lang/String;',
  );

  static final _benchmarkEventInserts = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String benchmarkEventInserts()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString benchmarkEventInserts() {
    return _benchmarkEventInserts(
            reference.pointer, _id_benchmarkEventInserts as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_benchmarkEventSelects = _class.instanceMethodId(
    r'benchmarkEventSelects',
    r'()Ljava/lang/String;',
  );

  static final _benchmarkEventSelects = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String benchmarkEventSelects()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString benchmarkEventSelects() {
    return _benchmarkEventSelects(
            reference.pointer, _id_benchmarkEventSelects as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_benchmarkEventInsertsAndSelects = _class.instanceMethodId(
    r'benchmarkEventInsertsAndSelects',
    r'(I)Ljava/lang/String;',
  );

  static final _benchmarkEventInsertsAndSelects =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final java.lang.String benchmarkEventInsertsAndSelects(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString benchmarkEventInsertsAndSelects(
    int i,
  ) {
    return _benchmarkEventInsertsAndSelects(reference.pointer,
            _id_benchmarkEventInsertsAndSelects as jni$_.JMethodIDPtr, i)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $DatabaseJniHelper$NullableType
    extends jni$_.JObjType<DatabaseJniHelper?> {
  @jni$_.internal
  const $DatabaseJniHelper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/database/DatabaseJniHelper;';

  @jni$_.internal
  @core$_.override
  DatabaseJniHelper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DatabaseJniHelper.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatabaseJniHelper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatabaseJniHelper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DatabaseJniHelper$NullableType) &&
        other is $DatabaseJniHelper$NullableType;
  }
}

final class $DatabaseJniHelper$Type extends jni$_.JObjType<DatabaseJniHelper> {
  @jni$_.internal
  const $DatabaseJniHelper$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/database/DatabaseJniHelper;';

  @jni$_.internal
  @core$_.override
  DatabaseJniHelper fromReference(jni$_.JReference reference) =>
      DatabaseJniHelper.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatabaseJniHelper?> get nullableType =>
      const $DatabaseJniHelper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatabaseJniHelper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DatabaseJniHelper$Type) &&
        other is $DatabaseJniHelper$Type;
  }
}

/// from: `com.example.database.Database$Companion`
class Database$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Database$Companion> $type;

  @jni$_.internal
  Database$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/example/database/Database$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Database$Companion$NullableType();
  static const type = $Database$Companion$Type();
  static final _id_getSchema = _class.instanceMethodId(
    r'getSchema',
    r'()Lapp/cash/sqldelight/db/SqlSchema;',
  );

  static final _getSchema = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final app.cash.sqldelight.db.SqlSchema getSchema()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getSchema() {
    return _getSchema(reference.pointer, _id_getSchema as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_invoke = _class.instanceMethodId(
    r'invoke',
    r'(Lapp/cash/sqldelight/db/SqlDriver;)Lcom/example/database/Database;',
  );

  static final _invoke = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.example.database.Database invoke(app.cash.sqldelight.db.SqlDriver sqlDriver)`
  /// The returned object must be released after use, by calling the [release] method.
  Database invoke(
    jni$_.JObject sqlDriver,
  ) {
    final _$sqlDriver = sqlDriver.reference;
    return _invoke(reference.pointer, _id_invoke as jni$_.JMethodIDPtr,
            _$sqlDriver.pointer)
        .object<Database>(const $Database$Type());
  }
}

final class $Database$Companion$NullableType
    extends jni$_.JObjType<Database$Companion?> {
  @jni$_.internal
  const $Database$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/database/Database$Companion;';

  @jni$_.internal
  @core$_.override
  Database$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Database$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Database$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Database$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Database$Companion$NullableType) &&
        other is $Database$Companion$NullableType;
  }
}

final class $Database$Companion$Type
    extends jni$_.JObjType<Database$Companion> {
  @jni$_.internal
  const $Database$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/database/Database$Companion;';

  @jni$_.internal
  @core$_.override
  Database$Companion fromReference(jni$_.JReference reference) =>
      Database$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Database$Companion?> get nullableType =>
      const $Database$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Database$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Database$Companion$Type) &&
        other is $Database$Companion$Type;
  }
}

/// from: `com.example.database.Database`
class Database extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Database> $type;

  @jni$_.internal
  Database.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/example/database/Database');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Database$NullableType();
  static const type = $Database$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/example/database/Database$Companion;',
  );

  /// from: `static public final com.example.database.Database$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static Database$Companion get Companion =>
      _id_Companion.get(_class, const $Database$Companion$Type());

  static final _id_getEventsQueries = _class.instanceMethodId(
    r'getEventsQueries',
    r'()Lcom/exampledatabase/EventsQueries;',
  );

  static final _getEventsQueries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.exampledatabase.EventsQueries getEventsQueries()`
  /// The returned object must be released after use, by calling the [release] method.
  EventsQueries getEventsQueries() {
    return _getEventsQueries(
            reference.pointer, _id_getEventsQueries as jni$_.JMethodIDPtr)
        .object<EventsQueries>(const $EventsQueries$Type());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Database> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getEventsQueries()Lcom/exampledatabase/EventsQueries;') {
        final $r = _$impls[$p]!.getEventsQueries();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Database $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.example.database.Database',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Database.implement(
    $Database $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Database.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Database {
  factory $Database({
    required EventsQueries Function() getEventsQueries,
  }) = _$Database;

  EventsQueries getEventsQueries();
}

final class _$Database with $Database {
  _$Database({
    required EventsQueries Function() getEventsQueries,
  }) : _getEventsQueries = getEventsQueries;

  final EventsQueries Function() _getEventsQueries;

  EventsQueries getEventsQueries() {
    return _getEventsQueries();
  }
}

final class $Database$NullableType extends jni$_.JObjType<Database?> {
  @jni$_.internal
  const $Database$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/database/Database;';

  @jni$_.internal
  @core$_.override
  Database? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Database.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Database?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Database$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Database$NullableType) &&
        other is $Database$NullableType;
  }
}

final class $Database$Type extends jni$_.JObjType<Database> {
  @jni$_.internal
  const $Database$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/database/Database;';

  @jni$_.internal
  @core$_.override
  Database fromReference(jni$_.JReference reference) => Database.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Database?> get nullableType => const $Database$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Database$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Database$Type) && other is $Database$Type;
  }
}

/// from: `com.exampledatabase.EventsQueries`
class EventsQueries extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EventsQueries> $type;

  @jni$_.internal
  EventsQueries.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/exampledatabase/EventsQueries');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EventsQueries$NullableType();
  static const type = $EventsQueries$Type();
  static final _id_new$ = _class.constructorId(
    r'(Lapp/cash/sqldelight/db/SqlDriver;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(app.cash.sqldelight.db.SqlDriver sqlDriver)`
  /// The returned object must be released after use, by calling the [release] method.
  factory EventsQueries(
    jni$_.JObject sqlDriver,
  ) {
    final _$sqlDriver = sqlDriver.reference;
    return EventsQueries.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$sqlDriver.pointer)
        .reference);
  }

  static final _id_getEvents = _class.instanceMethodId(
    r'getEvents',
    r'(Lkotlin/jvm/functions/Function5;)Lapp/cash/sqldelight/Query;',
  );

  static final _getEvents = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final app.cash.sqldelight.Query getEvents(kotlin.jvm.functions.Function5 function5)`
  /// The returned object must be released after use, by calling the [release] method.
  Query<$T> getEvents<$T extends jni$_.JObject>(
    jni$_.JObject function5, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$function5 = function5.reference;
    return _getEvents(reference.pointer, _id_getEvents as jni$_.JMethodIDPtr,
            _$function5.pointer)
        .object<Query<$T>>($Query$Type<$T>(T));
  }

  static final _id_getEvents$1 = _class.instanceMethodId(
    r'getEvents',
    r'()Lapp/cash/sqldelight/Query;',
  );

  static final _getEvents$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final app.cash.sqldelight.Query getEvents()`
  /// The returned object must be released after use, by calling the [release] method.
  Query<Events> getEvents$1() {
    return _getEvents$1(
            reference.pointer, _id_getEvents$1 as jni$_.JMethodIDPtr)
        .object<Query<Events>>(const $Query$Type<Events>($Events$Type()));
  }

  static final _id_getEventByEntityId = _class.instanceMethodId(
    r'getEventByEntityId',
    r'(Ljava/lang/String;Lkotlin/jvm/functions/Function5;)Lapp/cash/sqldelight/Query;',
  );

  static final _getEventByEntityId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final app.cash.sqldelight.Query getEventByEntityId(java.lang.String string, kotlin.jvm.functions.Function5 function5)`
  /// The returned object must be released after use, by calling the [release] method.
  Query<$T> getEventByEntityId<$T extends jni$_.JObject>(
    jni$_.JString string,
    jni$_.JObject function5, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string.reference;
    final _$function5 = function5.reference;
    return _getEventByEntityId(
            reference.pointer,
            _id_getEventByEntityId as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$function5.pointer)
        .object<Query<$T>>($Query$Type<$T>(T));
  }

  static final _id_getEventByEntityId$1 = _class.instanceMethodId(
    r'getEventByEntityId',
    r'(Ljava/lang/String;)Lapp/cash/sqldelight/Query;',
  );

  static final _getEventByEntityId$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final app.cash.sqldelight.Query getEventByEntityId(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  Query<Events> getEventByEntityId$1(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getEventByEntityId$1(reference.pointer,
            _id_getEventByEntityId$1 as jni$_.JMethodIDPtr, _$string.pointer)
        .object<Query<Events>>(const $Query$Type<Events>($Events$Type()));
  }

  static final _id_insertEvent = _class.instanceMethodId(
    r'insertEvent',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _insertEvent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void insertEvent(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4)`
  void insertEvent(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JString string2,
    jni$_.JString string3,
    jni$_.JString string4,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$string2 = string2.reference;
    final _$string3 = string3.reference;
    final _$string4 = string4.reference;
    _insertEvent(
            reference.pointer,
            _id_insertEvent as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer,
            _$string4.pointer)
        .check();
  }

  static final _id_resetDatabase = _class.instanceMethodId(
    r'resetDatabase',
    r'()V',
  );

  static final _resetDatabase = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void resetDatabase()`
  void resetDatabase() {
    _resetDatabase(reference.pointer, _id_resetDatabase as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $EventsQueries$NullableType extends jni$_.JObjType<EventsQueries?> {
  @jni$_.internal
  const $EventsQueries$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/exampledatabase/EventsQueries;';

  @jni$_.internal
  @core$_.override
  EventsQueries? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : EventsQueries.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EventsQueries?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EventsQueries$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EventsQueries$NullableType) &&
        other is $EventsQueries$NullableType;
  }
}

final class $EventsQueries$Type extends jni$_.JObjType<EventsQueries> {
  @jni$_.internal
  const $EventsQueries$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/exampledatabase/EventsQueries;';

  @jni$_.internal
  @core$_.override
  EventsQueries fromReference(jni$_.JReference reference) =>
      EventsQueries.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EventsQueries?> get nullableType =>
      const $EventsQueries$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EventsQueries$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EventsQueries$Type) &&
        other is $EventsQueries$Type;
  }
}

/// from: `com.exampledatabase.Events`
class Events extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Events> $type;

  @jni$_.internal
  Events.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/exampledatabase/Events');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Events$NullableType();
  static const type = $Events$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Events(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JString string2,
    jni$_.JString string3,
    jni$_.JString string4,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$string2 = string2.reference;
    final _$string3 = string3.reference;
    final _$string4 = string4.reference;
    return Events.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer,
            _$string4.pointer)
        .reference);
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getEntity_id = _class.instanceMethodId(
    r'getEntity_id',
    r'()Ljava/lang/String;',
  );

  static final _getEntity_id = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getEntity_id()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getEntity_id() {
    return _getEntity_id(
            reference.pointer, _id_getEntity_id as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAttribute = _class.instanceMethodId(
    r'getAttribute',
    r'()Ljava/lang/String;',
  );

  static final _getAttribute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getAttribute()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAttribute() {
    return _getAttribute(
            reference.pointer, _id_getAttribute as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getValue_ = _class.instanceMethodId(
    r'getValue_',
    r'()Ljava/lang/String;',
  );

  static final _getValue_ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getValue_()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getValue_() {
    return _getValue_(reference.pointer, _id_getValue_ as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getTimestamp = _class.instanceMethodId(
    r'getTimestamp',
    r'()Ljava/lang/String;',
  );

  static final _getTimestamp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getTimestamp()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getTimestamp() {
    return _getTimestamp(
            reference.pointer, _id_getTimestamp as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/String;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/String;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/String;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/String;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()Ljava/lang/String;',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lcom/exampledatabase/Events;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final com.exampledatabase.Events copy(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4)`
  /// The returned object must be released after use, by calling the [release] method.
  Events copy(
    jni$_.JString string,
    jni$_.JString string1,
    jni$_.JString string2,
    jni$_.JString string3,
    jni$_.JString string4,
  ) {
    final _$string = string.reference;
    final _$string1 = string1.reference;
    final _$string2 = string2.reference;
    final _$string3 = string3.reference;
    final _$string4 = string4.reference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer,
            _$string3.pointer,
            _$string4.pointer)
        .object<Events>(const $Events$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }
}

final class $Events$NullableType extends jni$_.JObjType<Events?> {
  @jni$_.internal
  const $Events$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/exampledatabase/Events;';

  @jni$_.internal
  @core$_.override
  Events? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Events.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Events?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Events$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Events$NullableType) &&
        other is $Events$NullableType;
  }
}

final class $Events$Type extends jni$_.JObjType<Events> {
  @jni$_.internal
  const $Events$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/exampledatabase/Events;';

  @jni$_.internal
  @core$_.override
  Events fromReference(jni$_.JReference reference) => Events.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Events?> get nullableType => const $Events$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Events$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Events$Type) && other is $Events$Type;
  }
}

/// from: `app.cash.sqldelight.Query$Listener`
class Query$Listener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Query$Listener> $type;

  @jni$_.internal
  Query$Listener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'app/cash/sqldelight/Query$Listener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Query$Listener$NullableType();
  static const type = $Query$Listener$Type();
  static final _id_queryResultsChanged = _class.instanceMethodId(
    r'queryResultsChanged',
    r'()V',
  );

  static final _queryResultsChanged = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void queryResultsChanged()`
  void queryResultsChanged() {
    _queryResultsChanged(
            reference.pointer, _id_queryResultsChanged as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Query$Listener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'queryResultsChanged()V') {
        _$impls[$p]!.queryResultsChanged();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Query$Listener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'app.cash.sqldelight.Query$Listener',
      $p,
      _$invokePointer,
      [
        if ($impl.queryResultsChanged$async) r'queryResultsChanged()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Query$Listener.implement(
    $Query$Listener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Query$Listener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Query$Listener {
  factory $Query$Listener({
    required void Function() queryResultsChanged,
    bool queryResultsChanged$async,
  }) = _$Query$Listener;

  void queryResultsChanged();
  bool get queryResultsChanged$async => false;
}

final class _$Query$Listener with $Query$Listener {
  _$Query$Listener({
    required void Function() queryResultsChanged,
    this.queryResultsChanged$async = false,
  }) : _queryResultsChanged = queryResultsChanged;

  final void Function() _queryResultsChanged;
  final bool queryResultsChanged$async;

  void queryResultsChanged() {
    return _queryResultsChanged();
  }
}

final class $Query$Listener$NullableType
    extends jni$_.JObjType<Query$Listener?> {
  @jni$_.internal
  const $Query$Listener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lapp/cash/sqldelight/Query$Listener;';

  @jni$_.internal
  @core$_.override
  Query$Listener? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Query$Listener.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Query$Listener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Query$Listener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Query$Listener$NullableType) &&
        other is $Query$Listener$NullableType;
  }
}

final class $Query$Listener$Type extends jni$_.JObjType<Query$Listener> {
  @jni$_.internal
  const $Query$Listener$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lapp/cash/sqldelight/Query$Listener;';

  @jni$_.internal
  @core$_.override
  Query$Listener fromReference(jni$_.JReference reference) =>
      Query$Listener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Query$Listener?> get nullableType =>
      const $Query$Listener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Query$Listener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Query$Listener$Type) &&
        other is $Query$Listener$Type;
  }
}

/// from: `app.cash.sqldelight.Query`
class Query<$RowType extends jni$_.JObject> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Query<$RowType>> $type;

  @jni$_.internal
  final jni$_.JObjType<$RowType> RowType;

  @jni$_.internal
  Query.fromReference(
    this.RowType,
    jni$_.JReference reference,
  )   : $type = type<$RowType>(RowType),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'app/cash/sqldelight/Query');

  /// The type which includes information such as the signature of this class.
  static $Query$NullableType<$RowType>
      nullableType<$RowType extends jni$_.JObject>(
    jni$_.JObjType<$RowType> RowType,
  ) {
    return $Query$NullableType<$RowType>(
      RowType,
    );
  }

  static $Query$Type<$RowType> type<$RowType extends jni$_.JObject>(
    jni$_.JObjType<$RowType> RowType,
  ) {
    return $Query$Type<$RowType>(
      RowType,
    );
  }

  static final _id_addListener = _class.instanceMethodId(
    r'addListener',
    r'(Lapp/cash/sqldelight/Query$Listener;)V',
  );

  static final _addListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void addListener(app.cash.sqldelight.Query$Listener listener)`
  void addListener(
    Query$Listener listener,
  ) {
    final _$listener = listener.reference;
    _addListener(reference.pointer, _id_addListener as jni$_.JMethodIDPtr,
            _$listener.pointer)
        .check();
  }

  static final _id_removeListener = _class.instanceMethodId(
    r'removeListener',
    r'(Lapp/cash/sqldelight/Query$Listener;)V',
  );

  static final _removeListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void removeListener(app.cash.sqldelight.Query$Listener listener)`
  void removeListener(
    Query$Listener listener,
  ) {
    final _$listener = listener.reference;
    _removeListener(reference.pointer, _id_removeListener as jni$_.JMethodIDPtr,
            _$listener.pointer)
        .check();
  }
}

final class $Query$NullableType<$RowType extends jni$_.JObject>
    extends jni$_.JObjType<Query<$RowType>?> {
  @jni$_.internal
  final jni$_.JObjType<$RowType> RowType;

  @jni$_.internal
  const $Query$NullableType(
    this.RowType,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lapp/cash/sqldelight/Query;';

  @jni$_.internal
  @core$_.override
  Query<$RowType>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Query<$RowType>.fromReference(
          RowType,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Query<$RowType>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Query$NullableType, RowType);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Query$NullableType<$RowType>) &&
        other is $Query$NullableType<$RowType> &&
        RowType == other.RowType;
  }
}

final class $Query$Type<$RowType extends jni$_.JObject>
    extends jni$_.JObjType<Query<$RowType>> {
  @jni$_.internal
  final jni$_.JObjType<$RowType> RowType;

  @jni$_.internal
  const $Query$Type(
    this.RowType,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lapp/cash/sqldelight/Query;';

  @jni$_.internal
  @core$_.override
  Query<$RowType> fromReference(jni$_.JReference reference) =>
      Query<$RowType>.fromReference(
        RowType,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Query<$RowType>?> get nullableType =>
      $Query$NullableType<$RowType>(RowType);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Query$Type, RowType);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Query$Type<$RowType>) &&
        other is $Query$Type<$RowType> &&
        RowType == other.RowType;
  }
}
